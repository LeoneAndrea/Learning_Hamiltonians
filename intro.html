
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Example &#8212; Learning_Hamiltonians 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Learning procedure" href="learn.html" />
    <link rel="prev" title="Installation" href="installation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="example">
<span id="intro"></span><h1>Example<a class="headerlink" href="#example" title="Permalink to this heading">¶</a></h1>
<section id="problem-description">
<h2>Problem description<a class="headerlink" href="#problem-description" title="Permalink to this heading">¶</a></h2>
<p>There is an increasing interest in modelling and computation of physical systems with neural networks,
given the the outstanding results they achieved in learning patterns from data. We consider Hamiltonian mechanical systems,
whose dynamics is fully determined by one scalar function, the Hamiltonian, which represent the energy of the system.
This explains why multiple approaches have been proposed to approximate this energy function,
and we focus here on the task of learning the Hamiltonians of contrained mechanical systems with neural networks,
given sample data information of their solutions.</p>
<p>Let us consider Hamiltonian functions of the form</p>
<div class="math notranslate nohighlight" id="equation-ham">
<span class="eqno">(1)<a class="headerlink" href="#equation-ham" title="Permalink to this equation">¶</a></span>\[\begin{align}
    H(q,p) = \frac{1}{2}p^TM^{-1}(q)p + V(q),
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(M(q)\)</span> is the mass matrix of the system, possibly depending on the configuration <span class="math notranslate nohighlight">\(q\in\mathbb{R}^n\)</span>, and <span class="math notranslate nohighlight">\(V(q)\)</span> is
the potential energy of the system.  The solution trajectories are often constrained to evolve on a submanifold of a linear vector space.
In particular, we focus on systems that are holonomically constrained on some configuration
manifold <span class="math notranslate nohighlight">\(\mathcal{Q}=\{q\in\mathbb{R}^n:\,g(q)=0\}\)</span> embedded in <span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span> and we model them by means of some projection operator.
As a result, the vector field is written in such a way that it directly respects the constraints, without the addition of algebraic equations.
We assume that the components <span class="math notranslate nohighlight">\(g_i:\mathbb{R}^n\rightarrow \mathbb{R}\)</span>, <span class="math notranslate nohighlight">\(i=1,...,m\)</span>, are functionally independent on the zero level set,
so that the Hamiltonian is defined on the <span class="math notranslate nohighlight">\((2n-2m)\)</span> dimensional cotangent bundle <span class="math notranslate nohighlight">\(\mathcal{M}=T^*\mathcal{Q}\)</span>. Working with elements
of the tangent space at <span class="math notranslate nohighlight">\(q\)</span>, <span class="math notranslate nohighlight">\(T_q\mathcal{Q}\)</span>, as vectors in <span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span>, we introduce a linear operator that defines the
orthogonal projection of an arbitrary vector <span class="math notranslate nohighlight">\(v\in\mathbb{R}^n\)</span> onto <span class="math notranslate nohighlight">\(T_q \mathcal{Q}\)</span>, i.e.</p>
<div class="math notranslate nohighlight" id="equation-proj">
<span class="eqno">(2)<a class="headerlink" href="#equation-proj" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \forall q\in \mathcal{Q},\text{ we set }P(q):\mathbb{R}^n\rightarrow T_q\mathcal{Q},\;\;v\mapsto P(q)v.
\end{align}\]</div>
<p><span class="math notranslate nohighlight">\(P(q)^T\)</span> can be seen as a map sending vectors of <span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span> into covectors in <span class="math notranslate nohighlight">\(T_q^*\mathcal{Q}\)</span>. If <span class="math notranslate nohighlight">\(g(q)\)</span> is differentiable,
assuming <span class="math notranslate nohighlight">\(G(q)\)</span> is the Jacobian matrix of <span class="math notranslate nohighlight">\(g(q)\)</span>, we have <span class="math notranslate nohighlight">\(T_q \mathcal{Q} = \mathrm{Ker}\,G(q)\)</span>, and
so <span class="math notranslate nohighlight">\(P(q) = I_n - G(q)\left(G(q)^TG(q)\right)^{-1}G(q)^T\)</span>, where <span class="math notranslate nohighlight">\(I_n\in\mathbb{R}^{n\times n}\)</span> is the identity matrix.
This projection map allows us to define Hamilton’s equations as follows</p>
<div class="math notranslate nohighlight" id="equation-chameq">
<span class="eqno">(3)<a class="headerlink" href="#equation-chameq" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
    \begin{cases}
    \dot{q} = P(q)\partial_pH(q,p)\\
    \dot{p} = -P(q)^T\partial_qH(q,p) + W(q,p)\partial_pH(q,p),
    \end{cases}
\end{align}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-wmatr">
<span class="eqno">(4)<a class="headerlink" href="#equation-wmatr" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
    \begin{split}
    W(q,p)&amp;=P(q)^T\Lambda(q,p)^T P(q) + \Lambda(q,p)P(q) -P(q)^T\Lambda(q,p)^T,\\ &amp;\text{with}\quad \Lambda(q,p) = \frac{\partial P(q)^Tp}{\partial q}.
    \end{split}
\end{align}\end{split}\]</div>
</section>
<section id="systems-defined-on-products-of-spheres">
<h2>Systems defined on products of spheres<a class="headerlink" href="#systems-defined-on-products-of-spheres" title="Permalink to this heading">¶</a></h2>
<p>Let the phase space of the system be <span class="math notranslate nohighlight">\(\mathcal{M}=(T^*S^2)^k\)</span>, where <span class="math notranslate nohighlight">\(S^2\)</span> is the unit sphere in <span class="math notranslate nohighlight">\(\mathbb{R}^3\)</span>, <span class="math notranslate nohighlight">\(k\in \mathbb{N}^+\)</span>.
We coordinatize <span class="math notranslate nohighlight">\(\mathcal{M}\)</span> with <span class="math notranslate nohighlight">\((q,p)=(q_1,\dots,q_k,p_1,\dots,p_k)\in \mathbb{R}^{6k}\)</span>. In this case, when <span class="math notranslate nohighlight">\(p\in \mathbb{R}^{3k}\)</span> is
intended as the vector of linear momenta, the matrix <span class="math notranslate nohighlight">\(M(q)\)</span> in equation <a class="reference internal" href="#equation-ham">(1)</a> is a block matrix, with</p>
<div class="math notranslate nohighlight" id="equation-mmatrp">
<span class="eqno">(5)<a class="headerlink" href="#equation-mmatrp" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
    i,j = 1,...,k,\quad \mathbb{R}^{3\times 3}\ni M(q)_{ij} = \begin{cases} m_{ii}I_3,\quad i=j\\
    m_{ij}(I_3-q_iq_i^T),\quad \text{otherwise,}
    \end{cases}
\end{align}\end{split}\]</div>
<p>The matrix having constant entries <span class="math notranslate nohighlight">\(m_{ij}\)</span> is symmetric and positive definite.</p>
<p>For example, in the case of a spherical pendulum we have <span class="math notranslate nohighlight">\(k=1\)</span>, hence the Hamiltonian dynamics is defined on its cotangent bundle <span class="math notranslate nohighlight">\(T^*S^2\)</span>.
With this specific choice of the geometry, the formulation presented in equation <a class="reference internal" href="#equation-chameq">(3)</a> simplifies considerably. Indeed <span class="math notranslate nohighlight">\(P(q) = I_3-qq^T\)</span> which
implies <span class="math notranslate nohighlight">\(W(q,p) = pq^T-qp^T\)</span>. Replacing these expressions in <a class="reference internal" href="#equation-chameq">(3)</a> and using the triple product rule we end up with the following set of ODEs</p>
<div class="math notranslate nohighlight" id="equation-hameqpend">
<span class="eqno">(6)<a class="headerlink" href="#equation-hameqpend" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
    \begin{cases}
    \dot{q} &amp;= (I-qq^T)\partial_pH(q,p)\\
    \dot{p} &amp;= -(I-qq^T)\partial_qH(q,p) + \partial_pH(q,p)\times (p\times q).
    \end{cases}
\end{align}\end{split}\]</div>
<p>This system is implemented in the following function to generate the training data.</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.trajectories.dynamics">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.trajectories.</span></span><span class="sig-name descname"><span class="pre">dynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.trajectories.dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>System of ODEs defining the dynamics</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>float</em>) – 1-D independent variable (time)</p></li>
<li><p><strong>z</strong> (<em>numpy.ndarray</em>) – 6N-component vector of configuration variables and conjugate momenta, with N the number of pendulums</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vec</strong> – 3N-component vector, with N the number of pendulums</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<p>This function in turn makes use of</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.trajectories.MatrR">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.trajectories.</span></span><span class="sig-name descname"><span class="pre">MatrR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.trajectories.MatrR" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix defining the quadratic kinetic energy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> (<em>numpy.ndarray</em>) – 3N-component vector of coordinates, with N the number of pendulums</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>R</strong> – 3Nx3N matrix defining the kinetic energy, with N the number of pendulums</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.trajectories.hat">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.trajectories.</span></span><span class="sig-name descname"><span class="pre">hat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.trajectories.hat" title="Permalink to this definition">¶</a></dt>
<dd><p>”
Isomorphism bewteen R3 and so(3). It returns the skew symmetric matrix hat(q) associated to the vector q,
such that hat(a)b=axb for all 3-component vectors a and b, with “x” the cross product</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> (<em>numpy.ndarray</em>) – 3-component vector</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>hat(q)</strong> – 3x3 skew-symmetric matrix (element of the Lie algebra so(3))</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.trajectories.Massm">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.trajectories.</span></span><span class="sig-name descname"><span class="pre">Massm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.trajectories.Massm" title="Permalink to this definition">¶</a></dt>
<dd><p>Mass matrix collecting the terms mij in the matrix defining the kinetic energy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nop</strong> (<em>int</em>) – number of pendulums</p></li>
<li><p><strong>m</strong> (<em>float</em>) – masses of the pendulums (supposed to be all the same in this case)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> – Mass matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<p>to define the Kinetic energy as in <a class="reference internal" href="#equation-ham">(1)</a> - <a class="reference internal" href="#equation-mmatrp">(5)</a>, and of</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.trajectories.Hq">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.trajectories.</span></span><span class="sig-name descname"><span class="pre">Hq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.trajectories.Hq" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient of the Hamiltonian with respect to the configuration variables</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>z</strong> (<em>numpy.ndarray</em>) – 6N-component vector of configuration variables and conjugate momenta, with N the number of pendulums</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Hp</strong> – 3N-component vector, with N the number of pendulums</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.trajectories.Hp">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.trajectories.</span></span><span class="sig-name descname"><span class="pre">Hp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.trajectories.Hp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient of the Hamiltonian with respect to the conjugate momenta</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>z</strong> (<em>numpy.ndarray</em>) – 6N-component vector of generalized coordinates and momenta, with N the number of pendulums</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Hp</strong> – 3N-component vector, with N the number of pendulums</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<p>to define the derivatives of the HAmiltonian function <a class="reference internal" href="#equation-ham">(1)</a>.</p>
<p>System <a class="reference internal" href="#equation-hameqpend">(6)</a> is also implemented in</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.main.predicted">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.main.</span></span><span class="sig-name descname"><span class="pre">predicted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.main.predicted" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector field predicted by using the evaluated Hamiltonian, to be used in scipy.integrate.solve_ivp
to get trajectory segments with the evaluated Hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>time</em>) – standard input to use the predicted function in scipi.integrate.solve_ivp</p></li>
<li><p><strong>HH</strong> (<em>torch.Tensor</em>) – trajectory point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vec</strong> (<em>torch.Tensor</em>) – vector field (Hamlton equations)</p></li>
<li><p><em>|</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<p>with the Hamitlonian function replaced by the Neural Network after the training procedure (i.e. the learned Hamiltonian) to evualte the approximation, and in</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.predictedVF">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">predictedVF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HH</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.predictedVF" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector field predicted by using the output of the neural network as the Hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>torch.Tensor</em>) – solution at time t0</p></li>
<li><p><strong>HH</strong> (<em>function handle</em>) – Hamiltonian</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vec</strong> – vector field (Hamlton equations)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p>with the Hamitlonian function replaced by the Neural Network during the training procedure (to solve the training equations with classical Runge–Kutta schemes).</p>
<p>We remarks briefly that <span class="math notranslate nohighlight">\(T^*S^2\)</span> is a homogeneous manifold, since it is acted upon transitively by the Lie group SE(3) through the group action</p>
<div class="math notranslate nohighlight" id="equation-act">
<span class="eqno">(7)<a class="headerlink" href="#equation-act" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \Psi : SE(3)\times T^*S^2\rightarrow T^*S^2,\;\;((R,r),(q,p^T))\mapsto (Rq,(Rp+r\times Rq)^T),
\end{align}\]</div>
<p>where the transpose comes from the usual interpretation of covectors as row vectors. This is implemented in</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.actionSE3NN">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">actionSE3NN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.actionSE3NN" title="Permalink to this definition">¶</a></dt>
<dd><p>Group action of SE3 on TS^2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> (<em>torch.Tensor</em>) – element of the group SE3</p></li>
<li><p><strong>z</strong> (<em>torch.Tensor</em>) – trajectory point in the phase space</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>out = torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p>The hat map is implemented in</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.hatNN">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">hatNN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.hatNN" title="Permalink to this definition">¶</a></dt>
<dd><p>It returns the skew symmetric matrix associated to the vector q, such
that hat(a)b=axb for all 3-component vectors a and b, with “x” the cross product</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> (<em>torch.Tensor</em>) – coordinates of the training trajectory points, with shape [batch size, s], s=3</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>res</strong> – skew symmetric matrix associated to each vector q in the batch, with shape [batch size, s, s], s=3</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p>As a consequence of <a class="reference internal" href="#equation-act">(7)</a>, we can use also Lie group integrators to solve numerically
the system <a class="reference internal" href="#equation-hameqpend">(6)</a>. In the <a class="reference external" href="https://github.com/THREAD-3-2/Learning_Hamiltonians/blob/main/Learning_Hamiltonians/main.py">code</a>, both Lie group
integrators (Lie-Euler and commutator-free of order 4) and classical Runge-Kutta schemes (Euler and Runge-Kutta of order four)
are implemented for the time integration of <a class="reference internal" href="#equation-hameqpend">(6)</a> during the training procedure.</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.LieEulerNN">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">LieEulerNN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.LieEulerNN" title="Permalink to this definition">¶</a></dt>
<dd><p>Lie Euler integrator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>torch.Tensor</em>) – solution at time t0</p></li>
<li><p><strong>f</strong> (<em>function handle</em>) – map f from the manifold M to the Lie algebra of the group acting on M</p></li>
<li><p><strong>h</strong> (<em>float</em>) – time step</p></li>
<li><p><strong>cc</strong> (<em>int</em>) – M-1</p></li>
<li><p><strong>H</strong> (<em>neural network class</em>) – Hamiltonian function</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sol</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>solution at time t1=t0+h</p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.CF4NN">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">CF4NN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.CF4NN" title="Permalink to this definition">¶</a></dt>
<dd><p>Lie group commutator free integrator of order 4</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>torch.Tensor</em>) – solution at time t0</p></li>
<li><p><strong>f</strong> (<em>function handle</em>) – map f from the manifold M to the Lie algebra of the group acting on M</p></li>
<li><p><strong>h</strong> (<em>float</em>) – time step</p></li>
<li><p><strong>cc</strong> (<em>int</em>) – M-1</p></li>
<li><p><strong>H</strong> (<em>neural network class</em>) – Hamiltonian function</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sol</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>solution at time t1=t0+h</p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.ExpEuler">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">ExpEuler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.ExpEuler" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicit Euler method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>torch.Tensor</em>) – solution at time t0</p></li>
<li><p><strong>f</strong> (<em>function handle</em>) – map f from the manifold M to the Lie algebra of the group acting on M</p></li>
<li><p><strong>h</strong> (<em>float</em>) – time step</p></li>
<li><p><strong>cc</strong> (<em>int</em>) – M-1</p></li>
<li><p><strong>H</strong> (<em>neural network class</em>) – Hamiltonian function</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sol</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>solution at time t1=t0+h</p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.RK4">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">RK4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.RK4" title="Permalink to this definition">¶</a></dt>
<dd><p>Runge-Kutta method of order 4</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>torch.Tensor</em>) – solution at time t0</p></li>
<li><p><strong>f</strong> (<em>function handle</em>) – map f from the manifold M to the Lie algebra of the group acting on M</p></li>
<li><p><strong>h</strong> (<em>float</em>) – time step</p></li>
<li><p><strong>cc</strong> (<em>int</em>) – M-1</p></li>
<li><p><strong>H</strong> (<em>neural network class</em>) – Hamiltonian function</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sol</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>solution at time t1=t0+h</p>
</dd>
</dl>
</dd></dl>

<p>Lie group integrators make use of the exponential maps on <span class="math notranslate nohighlight">\(SO(3)\)</span> and <span class="math notranslate nohighlight">\(SE(3)\)</span>, implemented respectively in</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.expso3NN">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">expso3NN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.expso3NN" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential map on SO(3)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>torch.Tensor</em><em> (</em><em>float32</em><em>)</em>) – element of the lie algebra so(3), represented as a vector with 3 components.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>expA</strong> – element of the group SO(3), i.e. 3x3 rotation matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.expse3NN">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">expse3NN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.expse3NN" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential map on SE(3)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>torch.Tensor</em><em> (</em><em>float32</em><em>)</em>) – element of the lie algebra se(3) represented as 6-component vector,
i.e. as a pair (u,v) with with the 3-component vector u corresponding
to a skew symmetric matrix hat(u) and the 3-component vector v
corresponding to the translational part.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>expA</strong> – element of the group SE(3), represented as a 3x4 matrix [A, b],
with A 3x3 rotation matrix and b 3-component translation vector.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p>We represent a generic element of the special Euclidean group <span class="math notranslate nohighlight">\(G=SE(3)\)</span> as
an ordered pair <span class="math notranslate nohighlight">\((R,r)\)</span>, where <span class="math notranslate nohighlight">\(R\in SO(3)\)</span> is a rotation matrix and <span class="math notranslate nohighlight">\(r\in\mathbb{R}^3\)</span> is a vector. The vector
field <span class="math notranslate nohighlight">\(X(q,p)\)</span> can be expressed as <span class="math notranslate nohighlight">\(\psi_*(F[H](q,p))(q,p)\)</span> with</p>
<div class="math notranslate nohighlight" id="equation-infgen">
<span class="eqno">(8)<a class="headerlink" href="#equation-infgen" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \psi_*((\xi,\eta))(q,p) = (\xi\times q,\xi\times p + \eta\times q), \quad (\xi,\eta)\in \mathfrak{g= se}(3)
\end{align}\]</div>
<p>and</p>
<div class="math notranslate nohighlight" id="equation-mapfham">
<span class="eqno">(9)<a class="headerlink" href="#equation-mapfham" title="Permalink to this equation">¶</a></span>\[\begin{align}
    F[H](q,p) = (\xi,\eta)=\left(q\times \frac{\partial H(q,p)}{\partial p},\frac{\partial H(q,p)}{\partial q}\times q + \frac{\partial H(q,p)}{\partial p}\times p \right).
\end{align}\]</div>
<p>A similar reasoning can be extended to a chain of <span class="math notranslate nohighlight">\(k\)</span> connected pendula, and hence to a system on <span class="math notranslate nohighlight">\((T^*S^2)^k\)</span>. The main idea is to replicate
both the equations and the expression <span class="math notranslate nohighlight">\(F[H]\)</span> for all the <span class="math notranslate nohighlight">\(k\)</span> copies of <span class="math notranslate nohighlight">\(T^*S^2\)</span>. A more detailed explanation can be found
in <a class="reference external" href="https://doi.org/10.1080/00207160.2021.1966772">(Celledoni, Çokaj, Leone, Murari and Owren, 2021)</a>.</p>
<p>The map <a class="reference internal" href="#equation-mapfham">(9)</a> for the double pendulum has been implemented in the following function</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.fManiAlgebraNN">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">fManiAlgebraNN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.fManiAlgebraNN" title="Permalink to this definition">¶</a></dt>
<dd><p>Funtion f from the manifold M (phase space of the system) to the Lie algebra of the group acting on M</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>torch.Tensor</em>) – Hamiltonian function</p></li>
<li><p><strong>z</strong> (<em>torch.Tensor</em>) – training trajectory points, with size [batch size, nop*2s]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ff</strong> – map f : M -&gt; g (Lie algebra)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p>and the extension of <a class="reference internal" href="#equation-act">(7)</a> to <span class="math notranslate nohighlight">\((T^*S^2)^k\)</span> in</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.actionse3NNn">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">actionse3NNn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.actionse3NNn" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate se3 actions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> (<em>torch.Tensor</em>) – elements of the group SE3</p></li>
<li><p><strong>z</strong> (<em>torch.Tensor</em>) – trajectory points in the phase space</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>out</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p>Finally, the extension of exponential map on <span class="math notranslate nohighlight">\(SE(3)\)</span> to <span class="math notranslate nohighlight">\((T^*S^2)^k\)</span> is implemented in</p>
<dl class="py function">
<dt class="sig sig-object py" id="Learning_Hamiltonians.nn_functions.expse3NNn">
<span class="sig-prename descclassname"><span class="pre">Learning_Hamiltonians.nn_functions.</span></span><span class="sig-name descname"><span class="pre">expse3NNn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Learning_Hamiltonians.nn_functions.expse3NNn" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate exponentials on SE(3) in one tensor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> (<em>torch.Tensor</em>) – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>out</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Learning_Hamiltonians</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Example</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#problem-description">Problem description</a></li>
<li class="toctree-l2"><a class="reference internal" href="#systems-defined-on-products-of-spheres">Systems defined on products of spheres</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="learn.html">Learning procedure</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="installation.html" title="previous chapter">Installation</a></li>
      <li>Next: <a href="learn.html" title="next chapter">Learning procedure</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Elena Celledoni, Andrea Leone, Davide Murari, Brynjulf Owren.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.2.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/intro.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>